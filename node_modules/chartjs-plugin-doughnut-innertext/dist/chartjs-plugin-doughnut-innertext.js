(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('chart.js')) :
  typeof define === 'function' && define.amd ? define(['chart.js'], factory) :
  (global['chartjs-plugin-doughnut-innertext'] = factory(global.Chart));
}(this, (function (chart_js) { 'use strict';

  var plugin = {
    id: "doughnutInnerText",
    beforeDraw: function beforeDraw(chart) {
      if (!chart.options.centerText) {
        return;
      }

      var chartArea = chart.chartArea;
      var top = chartArea.top;
      var left = chartArea.left;
      var height = chartArea.height;
      var width = chartArea.width;
      var centerText = chart.options.centerText;
      var ctx = chart.ctx;
      var fontSize = centerText.fontSize;

const wrapText = function(ctx, text, x, y, maxWidth, lineHeight) {
    // First, start by splitting all of our text into words, but splitting it into an array split by spaces
    let words = text.split(' ');
    let line = ''; // This will store the text of the current line
    let testLine = ''; // This will store the text when we add a word, to test if it's too long
    let lineArray = []; // This is an array of lines, which the function will return

    // Lets iterate over each word
    for(var n = 0; n < words.length; n++) {
        // Create a test line, and measure it..
        testLine += `${words[n]} `;
        let metrics = ctx.measureText(testLine);
        let testWidth = metrics.width;
        // If the width of this test line is more than the max width
        if (testWidth > maxWidth && n > 0) {
            // Then the line is finished, push the current line into "lineArray"
            lineArray.push([line, x, y]);
            // Increase the line height, so a new line is started
            y += lineHeight;
            // Update line and test line to use this word as the first word on the next line
            line = `${words[n]} `;
            testLine = `${words[n]} `;
        }
        else {
            // If the test line is still less than the max width, then add the word to the current line
            line += `${words[n]} `;
        }
        // If we never reach the full max width, then there is only one line.. so push it into the lineArray so we return something
        if(n === words.length - 1) {
            lineArray.push([line, x, y]);
        }
    }
    // Return the line array
    return lineArray;
}

      if (centerText.fontSizeAdjust) {
        fontSize = fontSize * (1 + centerText.fontSizeAdjust);
      }

      ctx.font = fontSize + "em sans-serif";
      ctx.textBaseline = "middle";
      var textX = Math.round((width - ctx.measureText(centerText.value).width) / 2 + left);
      var textY = Math.round(height / 2 + top);

      if (centerText.color) {
        ctx.fillStyle = centerText.color;
      }
      let wrappedText = wrapText(ctx, centerText.value, textX, textY, 1050, 140);
      wrappedText.forEach(function(item) {
    // item[0] is the text
    // item[1] is the x coordinate to fill the text at
    // item[2] is the y coordinate to fill the text at
    ctx.fillText(item[0], item[1], item[2]); 
})
    }
  }; // if the environment is neither amd nor commonjs, register the plugin globally for the samples and tests
  //   !(typeof define === "function" && define.amd) &&
  //   !(typeof module === "object" && module.exports)
  // ) {
  //   Chart.register(plugin);
  // }

  chart_js.Chart.register(plugin);

  return plugin;

})));
